var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Parameters","page":"API","title":"Parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Parameters of a model should be put in a YAML file with the structure below. Note that spaces and indentations are meaningful in YAML. Indentations should be spaces not tabs.","category":"page"},{"location":"api/","page":"API","title":"API","text":"See Examples for complete parameter file examples.","category":"page"},{"location":"api/","page":"API","title":"API","text":"- species:\n  - id: 1\n    parameter 1: ...\n    parameter 2: ...\n    ...\n  - id: 2\n    parameter 1: ... \n    parameter 2: ... \n    ...\n- model:\n  model parameter 1: ...\n  model parameter 2: ...\n  ...","category":"page"},{"location":"api/","page":"API","title":"API","text":"The file has two main levels: species and model. species stores species specific parameters as many different species as you want, starting with id 1. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Since we cannot write a matrix in a YAML file, any parameter that is a matrix should be converted to a vector. In Julia, you can do this by vec(yourmatrix).","category":"page"},{"location":"api/#Species-specific-parameters","page":"API","title":"Species specific parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Each species should have the following parameters. The order that you write these parameters does not matter.","category":"page"},{"location":"api/","page":"API","title":"API","text":"number of genes: An integer for number of genes that the species has.\nploidy: Either 1 for haploid or 2 for diploid genomes.\nnumber of phenotypes: An integer for the number of phenotypes that the species has.\nabiotic phenotypes: An array of integers (e.g. \"[1,2]\") specifying abiotic phenotypes among all phenotypes. Abiotic phenotypes determine how the species interacts with the environment.\nbiotic phenotypes: An array of integers (e.g. \"[3]\") specifying biotic phenotypes among all phenotypes. Biotic phenotypes determine how the species interacts with other individuals from the same or different species.\nmigration phenotype: An integer specifying the phenotype that determines migration trait. If the species does not migrate, put 0.\nvision radius: A number determining the radius of neighboring sites that the agent can see before migration.\ncheck fraction: A number between 0 and 1 showing the fraction of the visible sites to the agent that it can check and decide whether to migrate to.\nepistasis matrix: An epistasis matrix is of size l times l, where l is the product of number of genes and ploidy. Epistasis matrix specifies the direction (positive or negative) and size of effect of one locus on other loci. For example, if at row 1 and column 2 is a value 0.2, it means that locus 1 affects locus 2 by increasing the effect of locus 2 (because its positive) with 20% of the effect of locus 1.\npleiotropy matrix: A binary matrix (0s and 1s) with size number of phenotypes times l. The pleiotropy matrix specifies the phenotypes that each locus affects.\nexpression array: A vector of size l that represent the expression amount of each locus determining its effect size.\ngrowth rate: Mean of a Poisson distribution for number of offsprings per reproduction. This number is the maximum mean when fitness of a haploid individual is 1, or the distance between the biotic phenotypes of two diploid individuals is 0.\nselection coefficient: A number between 0 and 1 that determines the importance of fitness. 0 would be a model without selection.\nmutation probabilities: A vector of three numbers each of which specifies the probability for a different type of mutations: mutation probability of the expression array, pleiotropy matrix, and epistasis matrix, respectively. \nmutation magnitudes: A vector of numbers with the same size as mutation probabilities that determines the magnitude of mutation for each of the three categories. Specifically, the numbers are the variances of normal distributions with mean 0 for expression array and epistasis matrices, and probability of changing a 0 and 1 in in the pleiotropy matrix.\nN: A vector of integers for the initial number of individuals at each site.\nenvironmental noise: A number for the variance of a normal distribution with mean 0 that will be added to the phenotypes.\noptimal phenotype values: One or more vectors of numbers. Each vector should start with a dash and one indentation level. Each vector is the optimal phenotypes for each site for all abiotic traits. There are as many element as number of sites times number of abiotic traits. The first N elements are for the first abiotic trait, where N is the number of sites, and so on. \noptimal phenotypes: A vector of integers for optimal phenotype indices for each generation, including generation zero.\nage: An integer for maximum age of individuals of this species.\nrecombination: Mean of a Poisson distributions for number of crossing overs per sexual reproduction.\ninitial energy: A parameter for parental care of infants. Values more than 0 indicate that newly born individuals can survive for a number of times without requiring food from the environment/other species. The consumption rate (i.e. how many generations this initial energy suffices) is determined by the sum of the corresponding rows in \"food sources\" model parameter.","category":"page"},{"location":"api/#Model-parameters","page":"API","title":"Model parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"generations: An integer for the number of steps the model will run.\nspace: A vector of two integers that determine the size of a grid for space.\nmetric: Either \"chebyshev\" or \"euclidian\". Determines how many neighbors a space site has. \"chebyshev\" metric means that the r-neighborhood of a position are all positions within the hypercube having side length of 2*floor(r) and being centered in the origin position. \"euclidean\" metric means that the r-neighborhood of a position are all positions whose cartesian indices have Euclidean distance ≤ r from the cartesian index of the given position.\nperiodic: _Boolean__ (true or false) to determine whether boundaries of the space are connected or not.\nresources: A vector of integers determining available resources (e.g. vegetation) per site per time step. \ninteractions: A species-species interaction matrix of numbers determining how individuals from different species interact. Each value  is strength of interaction (between 0 and 1). Sign (+/-) is the direction of interaction where positive means similar individuals interact more strongly and negative is dissimilar ones tend to interact more.\nfood sources: A species-species food matrix of numbers determining what each species feeds on (consumption rate). Has priority over interactions. Non-zero diagonal means the food resource is from the environment. It will be read from rows (species order) to columns (species order). \nseed: Either an integer or Null for random number generator seed.","category":"page"},{"location":"api/#Simulation-outline","page":"API","title":"Simulation outline","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The simulations are fully agent-based, meaning that agents do not receive any model-level knowledge for what happens to them. The following steps happen in order to agents that are activated in a random order.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Grow one step older.\nMigrate.\nEat basic food if the species can.\nConsume energy.\nInteract with other species.\nIf meeting another individual of the same species but with different sex, reproduce.\nIf haploid, reproduce.\nSurvive if not tool old, has energy and by chance given its fitness.","category":"page"},{"location":"api/#Mutation","page":"API","title":"Mutation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Mutation can happen at three levels: changing the expression of each gene expressionArrays, changing the pleiotropy matrix pleiotropyMat, and changing the epistasis interactions between genes. The probability that a mutation occurs at each of these levels is controlled by parameter mutation probabilities. And size of mutations when they occur are controlled by parameter mutation magnitudes. The genotype vector y and pleiotropy matrix B of each individual mutates.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Epistasis matrix A and expression vectors Q mutate by adding their values to random numbers from a normal distribution with mean 0 and standard deviation given in parameter mutMagnitudes.","category":"page"},{"location":"api/","page":"API","title":"API","text":"B mutates by randomly switching 0s and 1s with probability given in parameter mutMagnitudes.","category":"page"},{"location":"api/#Fitness-update","page":"API","title":"Fitness update","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TODO","category":"page"},{"location":"api/#Migration","page":"API","title":"Migration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TODO","category":"page"},{"location":"api/#Reproduction","page":"API","title":"Reproduction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TODO","category":"page"},{"location":"api/#Survival","page":"API","title":"Survival","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TODO","category":"page"},{"location":"api/#Data-collection","page":"API","title":"Data collection","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The interface to the model is from the runmodel function (see Tutorial).","category":"page"},{"location":"api/","page":"API","title":"API","text":"EvoDynamics.jl uses Agents.jl underneath. See Agents.jl's documentation for details about writing functions to collect any data during simulations. Here, we explain the specific implementation of the model.","category":"page"},{"location":"api/","page":"API","title":"API","text":"There are two main objects from which you can collect data: and agent object of type AbstractAgent and a model object of type ABM. Both of these types are defined the Agents.jl package.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Agent object has the following fields: id, positions, species, epistasisMat (epistasis matrix), pleiotropyMat (pleiotropy matrix), and q (gene expression array).","category":"page"},{"location":"api/","page":"API","title":"API","text":"The model object has the following fields: space which is a GraphSpace or GridSpace object from Agents.jl, agents that is an array holding all agents, and properties which is a dictionary holding all the parameters passed to the model.","category":"page"},{"location":"api/","page":"API","title":"API","text":"To collect data, provide a dictionary where the keys are either agent fields, or :model. The value of a key is an array of any number of functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"If a key is an agent field, all the value of the field from all agents are collected and then aggregated with the functions in the value. For example, to collect mean and median fitness of individuals which is in field W, your dictionary will be Dict(:W => [mean, median]).","category":"page"},{"location":"api/","page":"API","title":"API","text":"If a key is :model, functions in its value array should be functions that accept a single argument, the model object, and return a single number or a tuple of numbers. For example, this is the default dictionary and its function:","category":"page"},{"location":"api/","page":"API","title":"API","text":"collect = Dict(:model => [mean_fitness_per_species])\n\n\"Returns a tuple whose entries are the mean fitness of each species.\"\nfunction mean_fitness_per_species(model::ABM)\n  nspecies = length(model.properties[:nphenotypes])\n  mean_fitness = Array{Float32}(undef, nspecies)\n  for species in 1:nspecies\n    fitness = mean([i.W for i in values(model.agents) if i.species == species])\n    mean_fitness[species] = fitness\n  end\n\n  return Tuple(mean_fitness)\nend","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"EditURL = \"https://github.com/kavir1698/EvoDynamics.jl/blob/master/examples/example2.jl\"","category":"page"},{"location":"example2/#Simplest-model","page":"Predator prey","title":"Simplest model","text":"","category":"section"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"Here we create a predator prey model of two species, one haploid and one diploid.","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"using EvoDynamics","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"Model parameters are in a YAML file as follows:","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"species:\nid: 1 number of genes: 7 number of phenotypes: 4 abiotic phenotypes: [1] biotic phenotypes: [2, 3] migration phenotype: 4  # can be 0 for no migration migration threshold: 3.5  # phenotypic threshold after which migration is possible vision radius: 1  # the radius of neighboring sites that the agent can see check fraction: 0.5  # the fraction of the observable sites that the agent checks ploidy: 2\nA random epistasis matrix where the diagonal is 1.0, meaning that each locus affects itself 100%.\nngenes x (ngenes x ploidy)\nepistasis matrix: [1.0, 0.34, 0.05, -0.12, 0.25, -0.47, 0.37, -0.32, 0.02, 0.41, 0.03, 0.0, 0.46, -0.22, 0.43, 1.0, 0.27, 0.33, 0.25, 0.19, 0.09, 0.15, -0.16, -0.18, 0.25, 0.44, -0.1, 0.21, -0.41, -0.19, 1.0, -0.48, -0.14, -0.24, -0.11, 0.4, 0.33, -0.16, 0.14, -0.34, 0.14, 0.46, 0.38, -0.36, 0.04, 1.0, 0.49, 0.41, 0.4, -0.24, 0.48, -0.4, -0.36, -0.42, -0.22, -0.01, 0.48, 0.38, 0.01, -0.4, 1.0, 0.08, 0.42, -0.21, -0.42, 0.01, 0.28, 0.37, -0.26, -0.35, -0.43, -0.28, -0.14, -0.48, 0.28, 1.0, 0.45, 0.5, 0.39, 0.04, -0.18, -0.04, 0.13, -0.11, -0.1, 0.24, 0.3, -0.22, -0.34, 0.11, 1.0, 0.22, 0.2, 0.07, 0.09, 0.43, -0.5, 0.25, -0.08, -0.22, -0.28, -0.36, -0.49, 0.03, -0.01, 1.0, -0.11, 0.2, -0.2, -0.25, -0.41, -0.03, -0.09, 0.12, 0.43, -0.24, 0.45, 0.15, -0.47, -0.33, 1.0, -0.37, 0.46, 0.21, -0.31, 0.18, -0.5, 0.12, -0.13, -0.07, -0.14, 0.49, 0.07, 0.48, 0.46, 1.0, -0.48, 0.19, 0.0, -0.38, 0.41, -0.12, 0.2, -0.12, 0.26, 0.04, 0.5, -0.49, -0.06, -0.33, 1.0, 0.29, -0.15, -0.4, 0.44, -0.39, -0.02, -0.49, -0.13, 0.41, 0.44, 0.07, 0.22, 0.49, -0.21, 1.0, 0.29, -0.28, -0.21, 0.21, 0.25, -0.37, -0.44, -0.19, -0.18, 0.5, -0.3, 0.05, 0.41, -0.02, 1.0, 0.05, -0.12, 0.26, -0.39, 0.27, -0.17, 0.13, -0.2, -0.07, 0.31, -0.42, -0.46, 0.06, 0.17, 1.0]\nnphenotype x (ngenes x ploidy)\npleiotropy matrix: [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0] growth rate: 0.8  # max number of offsprings per mating mean of a Poisson expression array: [0.28878032859775615, 0.4629421231828499, 0.26092147517051467, 0.952859489607121, 0.9638502824424, 0.05038142018016245, 0.05930756376654234, 0.033459292878885716, 0.32421526342800044, 0.9029235877297073, 0.7670060809312949, 0.12766808941531993, 0.8656895869985795, 0.342191940658253]  # ngenes x ploidy long selection coefficient: 0.5 mutation probabilities: [0.9, 0.0, 0.0]  # for gene expression array, pleiotropy matrix and epistasis matrix, respectively mutation magnitudes: [0.05, 0.0, 0.01]  # same as above N: [1000, 0, 0, 0]  # number of individuals per site at time 0 environmental noise: 0.01  # variance of a normal distribution with mean 0\neach row is the optimal phenotypes for each site for all abiotic traits. There are as many element as number of sites times number of abiotic traits. The first N elements are for the first abiotic trait, where N is the number of sites, and so on.\noptimal phenotype values:\n[2.8184972630154848, 1.2669190502061671, 1.7947315210311097, 0.5627451656026976]\n[2.3186137078797455, 0.7146284070374198, 1.7331797945458374, 1.6353360768904688]\nOptimal phenotype indices for each generation, including generation zero.\noptimal phenotypes: [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2] age: 5  # max age recombination: 1 # Mean of a Poisson distributions for number of crossing overs initial energy: 0 # A parameter for parental care of infants. Values more than 0 indicate that newly born individuals can survive for a number of times without requiring food from the environment/other species. The consumption rate (i.e. how many generations this initial energy suffices) is determined by the sum of the corresponding rows in \"food sources\"","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"id: 2 number of genes: 8 number of phenotypes: 5 abiotic phenotypes: [1,2] biotic phenotypes: [3, 4] migration phenotype: 5 migration threshold: 3.4 vision radius: 1 check fraction: 0.5 ploidy: 1 epistasis matrix: [1.0, 0.28, 0.0, 0.0, 0.31, -0.19, -0.43, 0.26, -0.01, 1.0, 0.28, -0.42, 0.47, 0.29, 0.38, 0.27, -0.01, -0.21, 1.0, 0.05, -0.42, -0.33, -0.06, -0.44, -0.34, -0.11, 0.1, 1.0, -0.34, -0.49, 0.39, -0.08, -0.42, 0.12, 0.09, -0.11, 1.0, 0.17, 0.21, 0.47, 0.18, -0.46, 0.3, -0.07, -0.4, 1.0, -0.5, -0.27, -0.09, 0.21, 0.1, -0.27, 0.16, -0.1, 1.0, -0.27, 0.13, -0.39, 0.17, 0.43, 0.11, -0.28, -0.08, 1.0] pleiotropy matrix: [1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1] covariance matrix: [0.11035, 0.2686, 0.6074, 0.6914, 0.8604, 0.2686, 0.6807, 0.1738, 0.619, 0.1465, 0.6074, 0.1738, 0.6494, 0.7646, 0.75, 0.6914, 0.619, 0.7646, 0.4658, 0.549, 0.8604, 0.1465, 0.75, 0.549, 0.6465] growth rate: 1.2 expression array: [0.24923147816626035, 0.7155732641738595, 0.9655184311211502, 0.8638149724268844, 0.5075272565823061, 0.9189652626508431, 0.7897640036022151, 0.17091233765481717] selection coefficient: 0.5 mutation probabilities: [0.9, 0.0, 0.0] mutation magnitudes: [0.05, 0.0, 0.01] N: [1000, 0, 0, 0] environmental noise: 0.01 optimal phenotype values:\n[0.7614758101208934, 2.2091361414343313, 0.7920974352892358, 2.587205421882114, 2.3911353663016586, 1.7858661540288683, 0.7630236717263839, 2.311211631439866]\n[0.6437641305315445, 0.9954545836033715, 2.469792530385348, 1.6158867433451882, 2.097629262577973, 1.1314248848669466, 1.490299526620522, 0.2566056477862022]\noptimal phenotypes: [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2] age: 3 recombination: 1 # Mean of a Poisson distributions for number of crossing overs initial energy: 0\nmodel:","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"generations: 14  # number of simulation steps   space: [2, 2]   metric: chebyshev  # how many neighbors a space site has. \"chebyshev\" metric means that the r-neighborhood of a position are all positions within the hypercube having side length of 2*floor(r) and being centered in the origin position. \"euclidean\" metric means that the r-neighborhood of a position are all positions whose cartesian indices have Euclidean distance ≤ r from the cartesian index of the given position.   periodic: false  # whether boundaries of the space are connected   resources: [200, 158, 183, 190]  # available resources per site per time   interactions: [0.1, 0.0, 0.0, -1.0]  # How individuals from different species interact. value  is strength of interaction (between 0 and 1). Sign is the direction of interaction where positive means similar individuals interact more strongly and negative is dissimilar ones tend to interact more.   food sources: [1.0, 0.5, 0.0, 0.0]  # What each species feeds on (consumption rate). Has priority over interactions. Non-zero diagonal means the food resource is from the environment. It will be read from rows (species order) to columns (species order).   seed: 2","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"agentdata, modeldata, model = runmodel(\"paramfile2.yml\")","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"EditURL = \"https://github.com/kavir1698/EvoDynamics.jl/blob/master/examples/example1.jl\"","category":"page"},{"location":"example1/#Simplest-model","page":"Simple Wright-Fisher","title":"Simplest model","text":"","category":"section"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"We can create and run simple Wright-Fisher simulations with EvoDynamics.jl. To that end, we define a single haploid species, in an unstructured space, with two single genes affecting biotic and abiotic traits, respectively.","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"using EvoDynamics","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"A simple one-species model with no spatial structure. Model parameters are in a YAML file as follows:","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"species:\nid: 1 number of genes: 2 number of phenotypes: 2 abiotic phenotypes: [1] biotic phenotypes: [2] migration phenotype: 0 migration threshold: 3.5 vision radius: 0 check fraction: 0 ploidy: 1 epistasis matrix: [1.0, 0.0, 0.0, 1.0] pleiotropy matrix: [1, 0, 0, 1] growth rate: 1.0 expression array: [0.28, 0.46] selection coefficient: 0.5 mutation probabilities: [0.9, 0.0, 0.0] mutation magnitudes: [0.05, 0.0, 0.0] N: [100] environmental noise: 0.01 optimal phenotype values:\n[1.76]\noptimal phenotypes: [1, 1, 1, 1, 1, 1] age: 2 recombination: 0 initial energy: 0\nmodel: generations: 5 space: [1,1] metric: chebyshev periodic: false resources: [200] interactions: [-0.1] food sources: [1.0] seed: Null","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"agentdata, modeldata, model = runmodel(\"paramfile1.yml\")","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#EvoDynamics.jl-Documentation","page":"Introduction","title":"EvoDynamics.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EvoDynamics.jl tries to bridge the gap in studying biological systems at small and large scales. Some studies only focus on single genes affecting single phenotypes, some studies only analyze gene interactions, some focus on populations, and some on species interactions. EvoDynamics.jl is a framework to study the effect of interactions between all these levels. It includes explicit pleiotropy, epistasis, selection acting on multiple phenotypes, different phenotypes affecting fitness at different amounts, arbitrary spatial structure, migration, and interacting species.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Figure below shows different biological levels controlled by the model.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Fig. 1. __Model structure.__)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We used the paper below as a starting point for this project. But EvoDynamics.jl goes way beyond that system by including multi-species interactions, spatial structure, and explicitly implementing epistasis and gene expression.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Melo, D., & Marroig, G. (2015). Directional selection can drive the evolution of modularity in complex traits. Proceedings of the National Academy of Sciences, 112(2), 470–475. https://doi.org/10.1073/pnas.1322632112","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See Tutorial for running the model, and API for a description of model parameters and simulation outline.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#EvoDynamics.jl's-basic-usage","page":"Tutorial","title":"EvoDynamics.jl's basic usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, define your model parameters in a YAML file (here, we call it parameters.yml). Examples has examples of initiation parameters. See API for a description of each parameter.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can the use the runmodel function to create a model from these parameters and run the simulation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"runmodel","category":"page"},{"location":"tutorial/#EvoDynamics.runmodel","page":"Tutorial","title":"EvoDynamics.runmodel","text":"runmodel(parameters::Dict; kwargs)\n\nCreates and runs a model given parameters. Returns a DataFrame of collected data, which are specified by kwargs.\n\nKeywords\n\nadata=[] agent data to be collected. Either agent fields or functions that accept an agent as input can be put in the array. To aggregate collected data, provide tuples inside the array. For example, to collect mean and median fitness of individuals which is in field W, your array will be [(:W,mean), (:W,median)].\nmdata=[meanfitnessper_species] model data to be collected. By default, collects mean population fitness per species. Each row of the output DataFrame corresponds to all agents and each column is the value function applied to a field. The functions in the array are applied to the model object.\nwhen=nothing The generations from which data are collected. By default collect at all steps.\nreplicates::Int = 0 Number of replicates per simulation.\nparallel::Bool = false Whether to run replicates in parallel. If true, you should add processors to your julia session (e.g. by addprocs(n)) and define your parameters and EvoDynamics on all workers. To do that, add @everywhere before them. For example, @everywhere EvoDynamics.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using EvoDynamics\nagentdata, modeldata, model = runmodel(\"parameters.yml\")","category":"page"}]
}
